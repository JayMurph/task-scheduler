using System;
using System.Collections.Generic;
using System.Text;

namespace task_scheduler_entities {
    /// <summary>
    /// Can be scheduled to produce notifications at pre-determined intervals.
    /// </summary>
    public class TaskItem : ITaskItem{
        
        /// <summary>
        /// Used to determine times at which the TaskItem should produce a Notification
        /// </summary>
        private INotificationPeriod period;
        /// <summary>
        /// Receives the notifications generated by the TaskItem
        /// </summary>
        private INotificationManager manager;
        /// <summary>
        /// Tracks time for the TaskItem
        /// </summary>
        private IClock clock;

        /// <summary>
        /// Used for adding the Notification generated by the TaskItem to its 
        /// INotificationManager as an asynchronous operation after a set period of time
        /// </summary>
        private DelayedTask notifier;

        /// <summary>
        /// The time at which the TaskItem is scheduled to begin producing notifications 
        /// </summary>
        private DateTime startTime;

        /// <summary>
        /// Title of the TaskItem
        /// </summary>
        public string Title{get;set;}

        /// <summary>
        /// Extra descriptive information for the TaskItem
        /// </summary>
        public string Comment { get; set; }

        /// <summary>
        /// Colour of the TaskItem when it is visually represented
        /// </summary>
        public Colour Colour { get; set; }

        /// <summary>
        /// The most recent time at which the TaskItem produced a notification. A value of
        /// DateTime.MinValue indicates that the TaskItem has not produced a any Notifications yet.
        /// </summary>
        public DateTime LastNotificationTime { get; private set; }

        /// <summary>
        /// The time at which the TaskItem is scheduled to being producing notifications
        /// </summary>
        public DateTime StartTime {
            get {
                return startTime;
            }
            set {
                startTime = value;
                if (IsActive) {
                    //notifier?.Cancel();
                    ScheduleNextNotification();
                }
            }
        }

        /// <summary>
        /// Indicates if the TaskItem is set to produce notifications
        /// </summary>
        public bool IsActive { get; private set; } = false;

        /// <summary>
        /// Creates a new TaskItem, assigns the incoming parameters to the appropriate properties,
        /// and makes the TaskItem active
        /// </summary>
        /// <param name="title">Title text for the TaskItem</param>
        /// <param name="comment">Extra descriptive info for the TaskItem</param>
        /// <param name="colour">Colour for visually representing the Notifications produced by the TaskItem</param>
        /// <param name="startTime">When the TaskItem should begin scheduling notifications</param>
        /// <param name="manager">Collects the notifications generated by the TaskItem</param>
        /// <param name="period">Determines the times at which the TaskItem should generate notifications</param>
        /// <param name="clock">Provides the current time for the TaskItem</param>
        /// <param name="lastNotificationTime">The most recent point in time at which the TaskItem
        /// produced a notification. Set to DateTime.MinValue to indicate that the TaskItem has
        /// never generated a notification
        /// </param>
        public TaskItem(
            string title,
            string comment,
            Colour colour,
            DateTime startTime,
            INotificationManager manager,
            INotificationPeriod period,
            IClock clock,
            DateTime lastNotificationTime
            ) {

            this.Title = title;
            this.Comment = comment;
            this.Colour = colour;
            this.LastNotificationTime = lastNotificationTime;

            this.startTime = startTime;

            this.manager = manager;
            this.period = period;
            this.clock = clock;

            while(IsOverdue()){
                PostNotification(period.NextNotificationTime(this.StartTime, this.LastNotificationTime)); 
            }

            IsActive = true;

            ScheduleNextNotification();
        }

        /// <summary>
        /// Creates a new TaskItem, assigns the incoming parameters to the appropriate properties,
        /// and makes the TaskItem active
        /// </summary>
        /// <param name="title">Title text for the TaskItem</param>
        /// <param name="comment">Extra descriptive info for the TaskItem</param>
        /// <param name="colour">Colour for visually representing the Notifications produced by the TaskItem</param>
        /// <param name="startTime">When the TaskItem should begin scheduling notifications</param>
        /// <param name="manager">Collects the notifications generated by the TaskItem</param>
        /// <param name="period">Determines the times at which the TaskItem should generate notifications</param>
        /// <param name="clock">Provides the current time for the TaskItem</param>
        public TaskItem(
            string title,
            string comment,
            Colour colour,
            DateTime startTime,
            INotificationManager manager,
            INotificationPeriod period,
            IClock clock
            ):
            this(title, comment, colour, startTime, manager, period, clock, DateTime.MinValue){
        }

        /// <summary>
        /// Stops the TaskItem from producing Notifications, making it inactive. The TaskItem
        /// cannot be restarted once this method is called.
        /// </summary>
        public void Cancel() {
            notifier?.Cancel();
            IsActive = false;
        }

        /// <summary>
        /// Assigns an INotificationPeriod to the TaskItem, for it to use to determine
        /// the points in time at which to generate notifications
        /// </summary>
        /// <param name="period">
        /// To be assigned to the TaskItem and used for determining when the TaskItem should
        /// produce notifications
        /// </param>
        public void ChangePeriod(INotificationPeriod period) {
            this.period = period;

            notifier?.Cancel();

            while(IsOverdue()){
                PostNotification(period.NextNotificationTime(this.StartTime, this.LastNotificationTime)); 
            }

            ScheduleNextNotification();
        }

        /// <summary>
        /// Indicates if the TaskItem is overdue for producing a Notification.
        /// </summary>
        /// <returns>
        /// True if the TaskItem should have produced a Notification according to its period and
        /// clock.
        /// </returns>
        private bool IsOverdue() {
            return period.NextNotificationTime(this.StartTime, this.LastNotificationTime) < clock.Now;
        }

        /// <summary>
        /// Schedules a new DelayedTask for the TaskItem, that will send a new Notification to the
        /// TaskItem's INotificationManager at the time determined by it's INotificationPeriod
        /// </summary>
        private void ScheduleNextNotification() {
            DateTime nextNotificationTime = period.NextNotificationTime(StartTime, clock.Now);

            notifier = 
                new DelayedTask(
                    () => { PostNotification(clock.Now); ScheduleNextNotification(); }, 
                    nextNotificationTime, 
                    clock
                );
        }

        /// <summary>
        /// Creates a Notification from the TaskItem and the incoming timeOfNotification,
        /// and adds it to the collection of the TaskItem's INotificationManager
        /// </summary>
        /// <param name="timeOfNotification">
        /// Time-stamp for the new Notification
        /// </param>
        private void PostNotification(DateTime timeOfNotification) {
            Notification notification = new Notification(this, timeOfNotification);

            LastNotificationTime = timeOfNotification;

            manager.Add(notification);
        }

        public void Dispose() {
            notifier?.Cancel();
        }

        ~TaskItem() {
            Dispose();
        }
    }
}
