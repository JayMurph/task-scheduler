using System;
using System.Collections.ObjectModel;
using task_scheduler_presentation.Models;
using Windows.UI.Xaml;
using Windows.UI.Xaml.Controls;
using Windows.UI.Xaml.Navigation;

namespace task_scheduler_presentation.Views {
    /// <summary>
    /// Page where Notifications generated by TaskItems are displayed
    /// </summary>
    public sealed partial class NotificationPage : Page, INotificationsView{
        /// <summary>
        /// Data that will be displayed on the page
        /// </summary>
        public ObservableCollection<NotificationModel> Notifications {
            get {
                return notificationListView.ItemsSource as ObservableCollection<NotificationModel>;
            }
            set {
                notificationListView.ItemsSource = value;
            }
        }

        /// <summary>
        /// Event to be executed when the page is closed
        /// </summary>
        public event EventHandler Closing;

        new public event EventHandler Loaded;

        public NotificationPage() {
            this.InitializeComponent();

            _controller = new Controllers.NotificationsController(this);
        }

        /// <summary>
        /// To be used as a delegate to a NotificationCreated event
        /// </summary>
        /// <param name="source">
        /// The sourc of the  event. unused
        /// </param>
        /// <param name="newNotification">
        /// The newly generated Notification
        /// </param>
        public async void NotificationCreatedCallback(object source, NotificationModel newNotification) {
            
            if(Window.Current.Dispatcher.HasThreadAccess == false) {
                //if we do not have thread access, keep calling this method until we do
                await Window.Current.Dispatcher.RunAsync(
                    Windows.UI.Core.CoreDispatcherPriority.Normal, 
                    ()=> { NotificationCreatedCallback(source, newNotification); }
                );
            }
            else {
                Notifications.Add(newNotification);
            }
        }

        /// <summary>
        /// Executed when the user navigates away from the NotificationPage. 
        /// </summary>
        /// <param name="e">base to base class method</param>
        protected override void OnNavigatedFrom(NavigationEventArgs e) {
            OnClosing(this, null);
            base.OnNavigatedFrom(e);
        }

        protected override void OnNavigatedTo(NavigationEventArgs e) {
            OnLoaded(this, null);
            base.OnNavigatedTo(e);
        }

        private readonly Controllers.NotificationsController _controller = null;

        private void OnLoaded(object source, EventArgs args) {
            Loaded?.Invoke(source, args);
        }

        /// <summary>
        /// Invokes the Closing event delegates
        /// </summary>
        /// <param name="source">Passed to invoke calls</param>
        /// <param name="args">Passed to invoke calls</param>
        private void OnClosing(object source, EventArgs args) {
            Closing?.Invoke(source, args);
        }
    }
}
